enum LendingAdapterType {
    MORPHO
}

enum RebalanceActionType {
    ADD_COLLATERAL
    REMOVE_COLLATERAL
    BORROW
    REPAY
}

enum OracleType {
    MORPHO_CHAINLINK
}

type LeverageManager @entity(immutable: false) {
    " Address of the LeverageManager "
    id: Bytes!
    " All LeverageTokens managed by this LeverageManager "
    leverageTokens: [LeverageToken!]! @derivedFrom(field: "leverageManager")
    " Total number of LeverageTokens managed by this LeverageManager "
    leverageTokensCount: BigInt!
    " Asset stats for all LeverageTokens managed by this LeverageManager "
    assetStats: [LeverageManagerAssetStats!]! @derivedFrom(field: "leverageManager")
    " Total number of unique LeverageToken holders across all LeverageTokens managed by this LeverageManager "
    totalHolders: BigInt!
}

type LeverageManagerAssetStats @entity(immutable: false) {
    " Address of the asset "
    id: Bytes!
    " Address of the LeverageManager "
    leverageManager: LeverageManager!
    " Total collateral of this asset managed by all LeverageTokens managed by this LeverageManager "
    totalCollateral: BigInt!
}

type LeverageToken @entity(immutable: false) {
    # ======== Configuration ========

    " Address of the LeverageToken "
    id: Bytes!
    " The LeverageManager that manages this LeverageToken "
    leverageManager: LeverageManager!
    " The LendingAdapter used by this LeverageToken "
    lendingAdapter: LendingAdapter!
    " The RebalanceAdapter used by this LeverageToken "
    rebalanceAdapter: Bytes!

    # ======== Leverage Position Balances ========

    " Current collateral ratio of the LeverageToken "
    collateralRatio: BigInt!

    " Current total collateral across all positions "
    totalCollateral: BigInt!
    " Current total collateral in debt asset across all positions "
    totalCollateralInDebt: BigInt!
    " Current total debt across all positions "
    totalDebt: BigInt!
    " Current total debt in collateral asset across all positions "
    totalDebtInCollateral: BigInt!

    " Current total equity in collateral asset "
    totalEquityInCollateral: BigInt!
    " Current total equity in debt asset "
    totalEquityInDebt: BigInt!

    " Current total supply of the LeverageToken "
    totalSupply: BigInt!
    " Current total number of unique LeverageToken holders "
    totalHolders: BigInt!

    " User positions in the LeverageToken "
    positions: [Position!]! @derivedFrom(field: "leverageToken")

    # ======== Fees Earned ========

    " Total mint token action fees earned "
    totalMintTokenActionFees: BigInt!
    " Total redeem token action fees earned "
    totalRedeemTokenActionFees: BigInt!
    " Total mint treasury fees earned in shares "
    totalMintTreasuryFees: BigInt!
    " Total redeem treasury fees earned in shares "
    totalRedeemTreasuryFees: BigInt!
    " Total management fees earned in shares "
    totalManagementFees: BigInt!

    # ======== Historical Data ========

    " Historical equity updates "
    equityUpdates: [EquityUpdate!]! @derivedFrom(field: "leverageToken")
    " Historical mint events "
    mints: [Mint!]! @derivedFrom(field: "leverageToken")
    " Historical redeem events "
    redeems: [Redeem!]! @derivedFrom(field: "leverageToken")
    # " Historical rebalances "
    # rebalances: [Rebalance!]! @derivedFrom(field: "leverageToken")

    # ======== Additional Metadata ========

    " Creation timestamp "
    createdTimestamp: BigInt!
    " Creation block number "
    createdBlockNumber: BigInt!
}

type LendingAdapter @entity(immutable: true) {
    " Address of the LendingAdapter "
    id: Bytes!
    " Type of the LendingAdapter (e.g., MORPHO) "
    type: LendingAdapterType!
    " Market ID of the LendingAdapter if type is MORPHO, null otherwise "
    morphoMarketId: Bytes
    " Address of the collateral asset "
    collateralAsset: Bytes!
    " Address of the debt asset "
    debtAsset: Bytes!
    " The oracle used by the LendingAdapter "
    oracle: Oracle!
}

type User @entity(immutable: false) {
    " Address of the user "
    id: Bytes!
    " Positions that the user has "
    positions: [Position!]! @derivedFrom(field: "user")
}

type Position @entity(immutable: false) {
    " { User address }-{ LT address } "
    id: ID!
    " Address of the user "
    user: User!
    " Address of the LeverageToken "
    leverageToken: LeverageToken!
    " Balance of the LeverageToken held by the user "
    balance: BigInt!
    " Equity in collateral asset of the position "
    equityInCollateral: BigInt!
    " Equity in debt asset of the position "
    equityInDebt: BigInt!
    " Historical mints "
    mints: [Mint!]! @derivedFrom(field: "position")
    " Historical redeems "
    redeems: [Redeem!]! @derivedFrom(field: "position")
    # TODO: Just store balance changes instead, we can derive equity changes by merging this dataset with the leverage token equity updates
    " Historical equity updates "
    equityUpdates: [PositionEquityUpdate!]! @derivedFrom(field: "position")
}

type Mint @entity(timeseries: true) {
    " Auto-incremented timeseries data point ID "
    id: Int8!
    " Position that the mint is for "
    position: Position!
    " Address of the LeverageToken "
    leverageToken: LeverageToken!
    " Amount of LeverageToken minted "
    amount: BigInt!
    " Equity amount added to the position in collateral asset "
    equityInCollateral: BigInt!
    " Equity amount added to the position in debt asset "
    equityInDebt: BigInt!
    " Token action fee for the mint "
    tokenActionFee: BigInt!
    " Treasury action fee for the mint "
    treasuryActionFee: BigInt!
    " Timestamp of the mint "
    timestamp: Timestamp!
    " Block number of the mint "
    blockNumber: BigInt!
}

type Redeem @entity(timeseries: true) {
    " Auto-incremented timeseries data point ID "
    id: Int8!
    " Position that the redeem is for "
    position: Position!
    " Address of the LeverageToken "
    leverageToken: LeverageToken!
    " Amount of LeverageToken redeemed "
    amount: BigInt!
    " Equity amount removed from the position in collateral asset "
    equityInCollateral: BigInt!
    " Equity amount removed from the position in debt asset "
    equityInDebt: BigInt!
    " Token action fee for the redeem "
    tokenActionFee: BigInt!
    " Treasury action fee for the redeem "
    treasuryActionFee: BigInt!
    " Timestamp of the redeem "
    timestamp: Timestamp!
    " Block number of the redeem "
    blockNumber: BigInt!
}

type Rebalance @entity(timeseries: true) {
    " Auto-incremented timeseries data point ID "
    id: Int8!
    " The LeverageToken that the rebalance is for "
    leverageToken: LeverageToken!
    " Rebalance actions "
    actions: [RebalanceAction!]!
    " Collateral ratio before the rebalance "
    collateralRatioBefore: BigInt!
    " Collateral ratio after the rebalance "
    collateralRatioAfter: BigInt!
    " Equity in collateral asset of the LeverageToken before the rebalance "
    equityInCollateralBefore: BigInt!
    " Equity in debt asset of the LeverageToken before the rebalance "
    equityInDebtBefore: BigInt!
    " Equity in collateral asset of the LeverageToken after the rebalance "
    equityInCollateralAfter: BigInt!
    " Equity in debt asset of the LeverageToken after the rebalance "
    equityInDebtAfter: BigInt!
    " The timestamp of the rebalance "
    timestamp: Timestamp!
    " The block number of the rebalance "
    blockNumber: BigInt!
}

type RebalanceAction @entity(immutable: true) {
    id: Bytes!
    " The type of rebalance action "
    type: RebalanceActionType!
    " The amount of collateral or debt added or removed, depending on the action type "
    amount: BigInt!
}

# TODO: call this LeverageTokenEquity
type EquityUpdate @entity(timeseries: true) {
    " Auto-incremented timeseries data point ID "
    id: Int8!
    " The LeverageToken that the equity update is for "
    leverageToken: LeverageToken!
    " The collateral ratio of the LeverageToken at the time of the update "
    collateralRatio: BigInt!
    " The total equity amount in collateral after this update "
    totalEquityInCollateral: BigInt!
    " The total equity amount in debt after this update "
    totalEquityInDebt: BigInt!
    " Timestamp of the update "
    timestamp: Timestamp!
    " Block number of the update "
    blockNumber: BigInt!
}

# TODO: call this PositionEquity
type PositionEquityUpdate @entity(timeseries: true) {
    " Auto-incremented timeseries data point ID "
    id: Int8!
    " The position that the equity update is for "
    position: Position!
    " The equity amount in collateral asset of the position "
    equityInCollateral: BigInt!
    " The equity amount in debt asset of the position "
    equityInDebt: BigInt!
    " The timestamp of the equity update "
    timestamp: Timestamp!
    " The block number of the equity update "
    blockNumber: BigInt!
}

type Oracle @entity(immutable: true) {
    " Address of the oracle "
    id: Bytes!
    " The type of the oracle "
    type: OracleType!
    " The current price of the oracle "
    price: BigInt!
    " The MorphoChainlinkOracle data, if oracle type is MORPHO_CHAINLINK "
    morphoChainlinkOracleData: MorphoChainlinkOracleData @derivedFrom(field: "oracle")
    " The timestamp of the current price "
    timestamp: Timestamp!
    " The block number of the current price "
    blockNumber: BigInt!
}

type MorphoChainlinkOracleData @entity(immutable: true) {
    id: Bytes!
    " The oracle that the MorphoChainlinkOracleData is for "
    oracle: Oracle!
    " The first base feed aggregator of the oracle "
    baseAggregatorA: ChainlinkAggregator!
    " The second base feed aggregator of the oracle "
    baseAggregatorB: ChainlinkAggregator
    " The first quote feed aggregator of the oracle "
    quoteAggregatorA: ChainlinkAggregator
    " The second quote feed aggregator of the oracle "
    quoteAggregatorB: ChainlinkAggregator
}

type ChainlinkAggregator @entity(immutable: true) {
    " Address of the Chainlink aggregator "
    id: Bytes!
    " The current price of the Chainlink aggregator "
    price: BigInt!
    " Price updates for the Chainlink aggregator "
    priceUpdates: [ChainlinkAggregatorPriceUpdate!]! @derivedFrom(field: "chainlinkAggregator")
}

type ChainlinkAggregatorPriceUpdate @entity(timeseries: true) {
    " Auto-incremented timeseries data point ID "
    id: Int8!
    " The Chainlink aggregator that the price update is for "
    chainlinkAggregator: ChainlinkAggregator!
    " The price on the this answer round "
    price: BigInt!
    " The round id of this answer round "
    roundId: BigInt!
    " The timestamp of this answer round "
    timestamp: Timestamp!
}