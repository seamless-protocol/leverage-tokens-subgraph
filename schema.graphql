enum LendingAdapterType {
    MORPHO
}

enum LeverageTokenBalanceChangeType {
    MINT
    REDEEM
    TRANSFER
}

enum RebalanceActionType {
    ADD_COLLATERAL
    REMOVE_COLLATERAL
    BORROW
    REPAY
}

enum OracleType {
    MORPHO_CHAINLINK
}

type LeverageManager @entity(immutable: false) {
    " Address of the LeverageManager "
    id: Bytes!
    " All LeverageTokens managed by this LeverageManager "
    leverageTokens: [LeverageToken!]! @derivedFrom(field: "leverageManager")
    " Total number of LeverageTokens managed by this LeverageManager "
    leverageTokensCount: BigInt!
    " Asset stats for all LeverageTokens managed by this LeverageManager "
    assetStats: [LeverageManagerAssetStats!]! @derivedFrom(field: "leverageManager")
    " Total number of current unique LeverageToken holders across all LeverageTokens managed by this LeverageManager "
    totalHolders: BigInt!

    " The oracles used by LeverageTokens managed by this LeverageManager "
    _oracles: [Oracle!]! @derivedFrom(field: "leverageManager")
}

type LeverageManagerAssetStats @entity(immutable: false) {
    " Address of the asset "
    id: Bytes!
    " Address of the LeverageManager "
    leverageManager: LeverageManager!
    " Total collateral of this asset managed by all LeverageTokens managed by this LeverageManager "
    totalCollateral: BigInt!
}

type LeverageToken @entity(immutable: false) {
    # ======== Configuration ========

    " Address of the LeverageToken "
    id: Bytes!
    " The LeverageManager that manages this LeverageToken "
    leverageManager: LeverageManager!
    " The LendingAdapter used by this LeverageToken "
    lendingAdapter: LendingAdapter!
    " The RebalanceAdapter used by this LeverageToken "
    rebalanceAdapter: RebalanceAdapter!

    # ======== Leverage Position Balances ========

    " Current collateral ratio of the LeverageToken "
    collateralRatio: BigInt!

    " Current total collateral across all positions "
    totalCollateral: BigInt!
    " Current total collateral in debt asset across all positions "
    totalCollateralInDebt: BigInt!

    " Current total supply of the LeverageToken "
    totalSupply: BigInt!
    " Current total number of unique LeverageToken holders "
    totalHolders: BigInt!

    " User positions in the LeverageToken "
    positions: [Position!]! @derivedFrom(field: "leverageToken")

    # ======== Fees Earned ========

    " Total mint token action fees earned "
    totalMintTokenActionFees: BigInt!
    " Total redeem token action fees earned "
    totalRedeemTokenActionFees: BigInt!
    " Total mint treasury fees earned in shares "
    totalMintTreasuryFees: BigInt!
    " Total redeem treasury fees earned in shares "
    totalRedeemTreasuryFees: BigInt!
    " Total management fees earned in shares "
    totalManagementFees: BigInt!

    # ======== Historical Data ========

    " Historical state updates "
    stateHistory: [LeverageTokenState!]! @derivedFrom(field: "leverageToken")
    " Historical balance changes "
    balanceChangeHistory: [LeverageTokenBalanceChange!]! @derivedFrom(field: "leverageToken")
    " Historical rebalances "
    rebalanceHistory: [Rebalance!]! @derivedFrom(field: "leverageToken")

    # ======== Additional Metadata ========

    " Creation timestamp "
    createdTimestamp: BigInt!
    " Creation block number "
    createdBlockNumber: BigInt!
}

type LendingAdapter @entity(immutable: true) {
    " Address of the LendingAdapter "
    id: Bytes!
    " Type of the LendingAdapter (e.g., MORPHO) "
    type: LendingAdapterType!
    " Market ID of the LendingAdapter if type is MORPHO, null otherwise "
    morphoMarketId: Bytes
    " Address of the collateral asset "
    collateralAsset: Bytes!
    " Address of the debt asset "
    debtAsset: Bytes!
    " The oracle used by the LendingAdapter "
    oracle: Oracle!
    " The LeverageTokens using this LendingAdapter "
    leverageTokens: [LeverageToken!]! @derivedFrom(field: "lendingAdapter")
}

type User @entity(immutable: false) {
    " Address of the user "
    id: Bytes!
    " Positions that the user has "
    positions: [Position!]! @derivedFrom(field: "user")
}

type Position @entity(immutable: false) {
    " { User address }-{ LT address } "
    id: ID!
    " Address of the user "
    user: User!
    " Address of the LeverageToken "
    leverageToken: LeverageToken!
    " Balance of the LeverageToken held by the user "
    balance: BigInt!
    " Equity deposited by the user in collateral asset of the position for the balance (i.e. the amount without any pnl) "
    totalEquityDepositedInCollateral: BigInt!
    " Equity deposited by the user in debt asset of the position for the balance (i.e. the amount without any pnl) "
    totalEquityDepositedInDebt: BigInt!
    " Historical balance changes "
    balanceChangeHistory: [LeverageTokenBalanceChange!]! @derivedFrom(field: "position")
}

type LeverageTokenBalanceChange @entity(timeseries: true) {
    " Auto-incremented timeseries data point ID "
    id: Int8!
    " The LeverageToken that the balance change is for "
    leverageToken: LeverageToken!
    " The position that the balance is for "
    position: Position!
    " The type of balance change (MINT, REDEEM, TRANSFER) "
    type: LeverageTokenBalanceChangeType!
    " The amount of shares held in the position with the change "
    amount: BigInt!
    " The balance added / removed to the position "
    amountDelta: BigInt!
    " The equity value of the balance added / removed in collateral asset "
    equityInCollateral: BigInt!
    " The equity value of the balance added / removed in debt asset "
    equityInDebt: BigInt!
    " The amount the user deposited for the shares in the collateral asset "
    equityDepositedInCollateral: BigInt!
    " The amount the user deposited for the shares in the debt asset "
    equityDepositedInDebt: BigInt!
    " The timestamp of this data point "
    timestamp: Timestamp!
    " The block number of this data point "
    blockNumber: BigInt!
}

type Rebalance @entity(immutable: true) {
    " Unique ID of the rebalance "
    id: ID!
    " The LeverageToken that the rebalance is for "
    leverageToken: LeverageToken!
    " Rebalance actions "
    actions: [RebalanceAction!]! @derivedFrom(field: "rebalance")
    " Collateral ratio before the rebalance "
    collateralRatioBefore: BigInt!
    " Collateral ratio after the rebalance "
    collateralRatioAfter: BigInt!
    " Equity in collateral asset of the LeverageToken before the rebalance "
    equityInCollateralBefore: BigInt!
    " Equity in debt asset of the LeverageToken before the rebalance "
    equityInDebtBefore: BigInt!
    " Equity in collateral asset of the LeverageToken after the rebalance "
    equityInCollateralAfter: BigInt!
    " Equity in debt asset of the LeverageToken after the rebalance "
    equityInDebtAfter: BigInt!
    " The dutch auction take for this rebalance, if the rebalance is a dutch auction rebalance "
    dutchAuctionTake: [DutchAuctionRebalanceAdapterAuctionTake!] @derivedFrom(field: "rebalance")
    " The timestamp of the rebalance "
    timestamp: Timestamp!
    " The block number of the rebalance "
    blockNumber: BigInt!
    " The log index of the rebalance event in the block this rebalance occurred in "
    logIndex: BigInt!
    " The transaction hash of the rebalance "
    transactionHash: Bytes!
}

type RebalanceAction @entity(immutable: true) {
    " {LeverageToken address}-{Rebalance index}-{Action index in Rebalance event} "
    id: ID!
    " The type of rebalance action "
    type: RebalanceActionType!
    " The amount of collateral or debt added or removed, depending on the action type "
    amount: BigInt!
    " The rebalance that the action is for "
    rebalance: Rebalance!
}

type LeverageTokenState @entity(timeseries: true) {
    " Auto-incremented timeseries data point ID "
    id: Int8!
    " The LeverageToken that the state is for "
    leverageToken: LeverageToken!
    " The collateral ratio of the LeverageToken "
    collateralRatio: BigInt!
    " The total collateral amount in the LeverageToken "
    totalCollateral: BigInt!
    " The total debt amount in the LeverageToken "
    totalDebt: BigInt!
    " The total equity amount in collateral in the LeverageToken "
    totalEquityInCollateral: BigInt!
    " The total equity amount in debt in the LeverageToken "
    totalEquityInDebt: BigInt!
    " The total supply of the LeverageToken "
    totalSupply: BigInt!
    " The equity value per LeverageToken in collateral "
    equityPerTokenInCollateral: BigInt!
    " The equity value per LeverageToken in debt "
    equityPerTokenInDebt: BigInt!
    " Timestamp of the update "
    timestamp: Timestamp!
    " Block number of the update "
    blockNumber: BigInt!
}

type LeverageTokenStateStats @aggregation(intervals: ["hour", "day"], source: "LeverageTokenState") {
    " Auto-generated ID of the aggregation bucket "
    id: Int8!
    " Beginning timestamp of the aggregation bucket "
    timestamp: Timestamp!
    " The LeverageToken whose state is aggregated "
    leverageToken: LeverageToken!
    " Last collateral ratio observed within the interval "
    lastCollateralRatio: BigInt! @aggregate(fn: "last", arg: "collateralRatio")
    " Minimum collateral ratio observed within the interval "
    minCollateralRatio: BigInt! @aggregate(fn: "min", arg: "collateralRatio")
    " Maximum collateral ratio observed within the interval "
    maxCollateralRatio: BigInt! @aggregate(fn: "max", arg: "collateralRatio")
    " Last total collateral observed within the interval "
    lastTotalCollateral: BigInt! @aggregate(fn: "last", arg: "totalCollateral")
    " Last total debt observed within the interval "
    lastTotalDebt: BigInt! @aggregate(fn: "last", arg: "totalDebt")
    " Last total equity in collateral observed within the interval "
    lastTotalEquityInCollateral: BigInt! @aggregate(fn: "last", arg: "totalEquityInCollateral")
    " Last total equity in debt observed within the interval "
    lastTotalEquityInDebt: BigInt! @aggregate(fn: "last", arg: "totalEquityInDebt")
    " Last total supply observed within the interval "
    lastTotalSupply: BigInt! @aggregate(fn: "last", arg: "totalSupply")
    " Last equity per token in collateral observed within the interval "
    lastEquityPerTokenInCollateral: BigInt! @aggregate(fn: "last", arg: "equityPerTokenInCollateral")
    " Last equity per token in debt observed within the interval "
    lastEquityPerTokenInDebt: BigInt! @aggregate(fn: "last", arg: "equityPerTokenInDebt")
    " Last block number observed within the interval "
    lastBlockNumber: BigInt! @aggregate(fn: "last", arg: "blockNumber")
    " Number of state observations captured within the interval "
    observationCount: BigInt! @aggregate(fn: "count")
}

type Oracle @entity(immutable: false) {
    " Address of the oracle "
    id: Bytes!
    " The LeverageManager that uses this oracle "
    leverageManager: LeverageManager!
    " The type of the oracle "
    type: OracleType!
    " The current price of the oracle "
    price: BigInt!
    " The decimals of the oracle price "
    decimals: Int!
    " The MorphoChainlinkOracle data, if oracle type is MORPHO_CHAINLINK "
    morphoChainlinkOracleData: MorphoChainlinkOracleData
    " The price updates for the oracle "
    priceUpdates: [OraclePrice!]! @derivedFrom(field: "oracle")
    " The LendingAdapters using this oracle "
    lendingAdapters: [LendingAdapter!]! @derivedFrom(field: "oracle")
}

type OraclePrice @entity(timeseries: true) {
    " Auto-incremented timeseries data point ID "
    id: Int8!
    " The oracle that the price is for "
    oracle: Oracle!
    " The price of the oracle "
    price: BigInt!
    " The timestamp of the price "
    timestamp: Timestamp!
}

type OraclePriceStats @aggregation(intervals: ["hour", "day"], source: "OraclePrice") {
    " Auto-generated ID of the aggregation bucket "
    id: Int8!
    " Beginning timestamp of the aggregation bucket "
    timestamp: Timestamp!
    " The oracle whose prices are aggregated "
    oracle: Oracle!
    " Last price observed within the interval "
    lastPrice: BigInt! @aggregate(fn: "last", arg: "price")
    " Minimum price observed within the interval "
    minPrice: BigInt! @aggregate(fn: "min", arg: "price")
    " Maximum price observed within the interval "
    maxPrice: BigInt! @aggregate(fn: "max", arg: "price")
    " Number of price observations captured within the interval "
    observationCount: BigInt! @aggregate(fn: "count")
}

type MorphoChainlinkOracleData @entity(immutable: true) {
    id: Bytes!
    " The oracle that the MorphoChainlinkOracleData is for "
    oracle: Oracle!
    " The scale factor of the MorphoChainlinkOracle "
    scaleFactor: BigInt!
    " The base vault address of the oracle "
    baseVault: Bytes!
    " The quote vault address of the oracle "
    quoteVault: Bytes!
    " The first base feed aggregator of the oracle "
    baseAggregatorA: ChainlinkAggregator!
    " The second base feed aggregator of the oracle "
    baseAggregatorB: ChainlinkAggregator
    " The first quote feed aggregator of the oracle "
    quoteAggregatorA: ChainlinkAggregator
    " The second quote feed aggregator of the oracle "
    quoteAggregatorB: ChainlinkAggregator
}

type ChainlinkAggregator @entity(immutable: false) {
    " Address of the Chainlink aggregator "
    id: Bytes!
    " The current price of the Chainlink aggregator "
    price: BigInt!
    " The decimals of the Chainlink aggregator price "
    decimals: Int!
}

type RebalanceAdapter @entity(immutable: false) {
    " The address of the rebalance adapter "
    id: Bytes!
    " The LeverageToken that the rebalance adapter is for "
    leverageToken: LeverageToken!
    " The dutch auction rebalance adapter data, if the rebalance adapter is using DutchAuctionRebalanceAdapter "
    dutchAuctionRebalanceAdapter: DutchAuctionRebalanceAdapter
}

type DutchAuctionRebalanceAdapter @entity(immutable: false) {
    " The address of the rebalance adapter "
    id: Bytes!
    " The rebalance adapter that the dutch auction rebalance adapter is for "
    rebalanceAdapter: RebalanceAdapter!
    " History of auctions "
    auctionHistory: [DutchAuctionRebalanceAdapterAuction!]! @derivedFrom(field: "dutchAuctionRebalanceAdapter")
    " The maximum duration allowed for auctions "
    maxDuration: BigInt!
    " The total number of auctions that have happened "
    totalAuctions: BigInt!
    " The current on-going auction, if there is one. Note: This is only updated when the auction is updated on chain, so it may not be accurate in real time if the max duration has elapsed "
    _currentAuction: DutchAuctionRebalanceAdapterAuction
}

type DutchAuctionRebalanceAdapterAuction @entity(immutable: false) {
    " {RebalanceAdapter address}-{Auction Number} "
    id: ID!
    " The dutch auction rebalance adapter that the auction is for "
    dutchAuctionRebalanceAdapter: DutchAuctionRebalanceAdapter!
    " The collateral ratio of the LeverageToken when the auction was created "
    collateralRatioAtCreation: BigInt!
    " History of takes on this auction "
    auctionTakeHistory: [DutchAuctionRebalanceAdapterAuctionTake!]! @derivedFrom(field: "auction")
    " Timestamp the auction was created "
    timestamp: Timestamp!
    " Timestamp the auction was completed, null if not yet ended "
    timestampCompleted: Timestamp
}

type DutchAuctionRebalanceAdapterAuctionTake @entity(timeseries: true) {
    " Auto-incremented timeseries data point ID "
    id: Int8!
    " The auction that the take is for "
    auction: DutchAuctionRebalanceAdapterAuction!
    " Price multiplier taken on the auction "
    priceMultiplier: BigInt!
    " Amount in "
    amountIn: BigInt!
    " Amount out "
    amountOut: BigInt!
    " The rebalance for this take "
    rebalance: Rebalance
    " The timestamp the take was made "
    timestamp: Timestamp!
}

type DutchAuctionRebalanceAdapterAuctionTakeStats @aggregation(intervals: ["hour", "day"], source: "DutchAuctionRebalanceAdapterAuctionTake") {
    " Auto-generated ID of the aggregation bucket "
    id: Int8!
    " Beginning timestamp of the aggregation bucket "
    timestamp: Timestamp!
    " The auction whose takes are aggregated "
    auction: DutchAuctionRebalanceAdapterAuction!
    " The rebalance associated with the aggregated takes, if available "
    rebalance: Rebalance
    " Total amount in across all takes within the interval "
    totalAmountIn: BigInt! @aggregate(fn: "sum", arg: "amountIn")
    " Total amount out across all takes within the interval "
    totalAmountOut: BigInt! @aggregate(fn: "sum", arg: "amountOut")
    " Last price multiplier observed within the interval "
    lastPriceMultiplier: BigInt! @aggregate(fn: "last", arg: "priceMultiplier")
    " Number of takes captured within the interval "
    takeCount: BigInt! @aggregate(fn: "count")
}